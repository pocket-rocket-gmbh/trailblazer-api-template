class BaseOperation < Trailblazer::Operation
  # needed to make class dependencies (self['xxxx']) possible
  extend ClassDependencies
  
  step :initialize_errors

  # -------------- Steps ---------------------
  # initialize the options['errors'] array
  def initialize_errors(options, **)
    options['errors'] = []
  end

  # --------------- Helpers -----------------

  # Adds an error to the options['errors'] hash
  #
  # @param options [Hash] the operation options that are passed along
  # @param message [String] a message to describe the exception
  # @param exception [StandardError] the exception
  # @param code [String] an identifier for the error
  # @param field_name [String] if it is a validation error: the name of the field that could not be validated
  def add_error(options, message:, exception: nil, code:, field_name: nil)
    options['errors'] << { code: code,
      message: message, exception: exception, field_name: field_name }
  end

  # @param options [Hash] the operation options that are passed along
  # @param errors [Array] an array of error objects to add to the errors array
  def add_errors(options, errors:)
    return if errors.count < 1
    errors.each do |err|
      add_error(options, message: err[:message], exception: err[:exception],
        field_name: err[:field_name], code: err[:code])
    end
  end

  # Adds errors from contracts when present
  # Logs errors to the logger
  def process_errors(options, **)
    add_contract_errors(options)
    log_errors(options)
  end

  # Used for getting scoped reesults in logic list operations
  #
  # Requires options['policy'] to be set to a policy with a declared resolve method
  # sets the model to the scope generated by the policy#resolve call
  def set_model_to_scoped_query(options, policy:, **)
    options['model'] = policy.resolve
    return true
  end

  # sets the model to a will_paginated collection
  # this is executed after the query is already prepared by the policy#resolve
  # method call of the according concept's policy
  #
  # Allows customizing the sort order and sort field as described below
  # retrieves the according prepared query from options['model']
  # retrieves the according field to sort by from options['list.sort_by']
  # retrieves the according order from options['list.sort_order'] (default: ASC)
  def retrieve_list(options, params:, policy:, **)
    logger.info "Executing #{self} #retrieve_list"

    sort_by = "id"
    sort_order = "ASC"

    # process sorting params from request
    unless params[:sort_by].nil?
      params[:sort_by] = params[:sort_by].join(', ') if params[:sort_by].class == Array
      options['list.sort_by'] = params[:sort_by].split.first.downcase
    end

    unless params[:sort_order].nil?
      params[:sort_order] = params[:sort_order].join(', ') if params[:sort_order].class == Array
      options['list.sort_order'] = params[:sort_order].split.first.upcase
    end

    if !options['list.sort_by'].nil? && options['list.sort_by'].class == String
      # ensure to leave out injections
      sort_by = options['list.sort_by'].split(' ').first
    end

    if !options['list.sort_order'].nil? && ['ASC','DESC'].include?(options['list.sort_order'])
      sort_order = options['list.sort_order']
    end

    unless sort_by.nil?
      if sort_by == 'id' || sort_by == 'created_at' || sort_by == 'updated_at'
        options['model'] = options['model'].reorder("#{options['model'].table_name}.#{sort_by} #{sort_order} NULLS LAST")
      elsif options['model'].column_names.include?(sort_by)
        # Find which model the sort_by exists on if it's not current table, join it and put the search in the query
        # No point in handling wrong input data here as Postgres will complain anyway when the query is run
        # Allow sorting on columns of other objects
        # ignore cases
        options['model'] = options['model'].order("lower(#{options['model'].table_name}.#{sort_by}) #{sort_order} NULLS LAST")
      end
    end

    if !options['disable_pagination'] && !options['show_endpoint']
      options['model'] = options['model'].paginate(
        get_list_pagination_params(options, params: params))
    end

    return true
  end

  # Could be refactored with Subprocess but it has the same effort

  def call_nested_logic_operation(operation_class, options, params:, policy:, request: nil, **)
    current_user_id = nil
    current_user_id = options['current_user'].id unless options['current_user'].nil?

    logger.debug "Executing call_nested_logic_operation with operation_class: #{operation_class}, current_user_id: #{current_user_id}, policy_class: #{options['policy'].class}"

    result = operation_class.(
      params: params,
      current_user: options['current_user'],
      current_organization: options['current_organization'],
      request: request,
      policy: policy,
      'current_user' => options['current_user'],
      'current_organization' => options['current_organization'],
      'policy' => policy,
      'request' => request
    )

    options['model'] = result['model']

    options['pagination.page'] = result['pagination.page'] unless result['pagination.page'].nil?
    options['pagination.per_page'] = result['pagination.per_page'] unless result['pagination.per_page'].nil?
    options['policy'] = result['policy']
    options['errors'] = options['errors'].concat result['errors'] unless result['errors'].nil?
    options['http_status'] = result['http_status'] unless result['http_status'].nil?
    options['json'] = result['json'] unless result['json'].nil?
    options['request'] = result['request'] unless result['request'].nil?
    options['result'] = result['result'] unless result['result'].nil?
    options['disable_pagination'] = result['disable_pagination'] unless result['disable_pagination'].nil?

    return result.success?
  end

protected

  # iterates the contract errors and formats it to the options['errors'] format
  def add_contract_errors(options)
    if !options['contract.default'].nil? && options['contract.default'].respond_to?(:errors)
      options['contract.default'].errors.messages.each do |err|
        add_error options, message: "#{err.first} #{err.last.last}", code: "#{options['contract.default'].model.class.to_s.downcase}.#{err.first}.invalid", field_name: err.first
      end
    end
  end

  # Writes the options['errors'] array out using the logger
  #
  # @param options [Hash] the operation options that are passed along
  def log_errors(options)
    unless options['errors'].nil?
      options['errors'].each do |err_hash|
        logger.error("Code: #{err_hash[:code]} - FieldName: #{err_hash[:field_name]} - Exception: #{err_hash[:exception]} - #{err_hash[:message]}")
      end
    end
  end

  # returns the pagination params if set, returns defaults otherwise
  def get_list_pagination_params(options, params: , **)
    page = 1
    per_page = 30

    begin
      page = params[:page].to_i unless params[:page].nil?
      page = 1 if page <= 0
      per_page = params[:per_page].to_i.abs unless params[:per_page].nil?
    rescue StandardError => err
      logger.warn err.message
    end

    options['pagination.page'] = page
    options['pagination.per_page'] = per_page
    {
      page: page,
      per_page: per_page
    }
  end

  def logger
    Rails.logger
  end
end
